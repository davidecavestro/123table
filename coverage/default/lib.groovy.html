<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>lib.groovy</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Coverage Report</a> &gt; <a href="index.source.html" class="el_package">default</a> &gt; <span class="el_source">lib.groovy</span></div><h1>lib.groovy</h1><pre class="source lang-java linenums">// @Grab('net.sourceforge.csvjdbc:csvjdbc:1.0.46')

import groovy.sql.Sql
import java.sql.Driver

def getDriverClassName(String url) {
<span class="pc bpc" id="L7" title="2 of 4 branches missed.">    if (!url) return null</span>

<span class="fc" id="L9">    def drivers</span>

    // Register drivers and get the first one that accepts the URL
<span class="pc bpc" id="L12" title="2 of 4 branches missed.">    if (!drivers) {</span>
<span class="fc" id="L13">        drivers = ServiceLoader.load(Driver)</span>
    }

<span class="fc" id="L16">    def driver = drivers.find { driver -&gt;</span>
        try {
            driver.acceptsURL(url)
        } catch (e) {
            false
        }
    }

<span class="fc" id="L24">    driver?.getClass()?.name</span>
}

def execute(def opts) {
<span class="nc" id="L28">    opts.tap {</span>
// println &quot;sourceDbUrl: ${sourceDbUrl}&quot;

        Sql.withInstance(
            sourceDbUrl,
            sourceDbUser,
            sourceDbPassword,
        ) { def sourceDb -&gt;
            def targetFields = sourceDb.firstRow(sourceQuery)?.collect { def name, def value -&gt;
                [name: name, type: 'VARCHAR']
            }
            // def targetFields = sourceDb.query(sourceQuery) {def rs -&gt;
            //     def ret
            //     if (rs.next()){
            //         ret = rs.getMetaData()?.with { def md -&gt;
            //             (1..md.columnCount).collectEntries { [name: md.getColumnName(it)] }
            //         }
            //         if (!ret){
            //             ret = 
            //         }
            //     }
            //     ret
            // }
            if (!targetFields) {
                println 'No source row found (empty table?)'
                return
            }

            println &quot;Using targetFields: ${targetFields}&quot; 
            def targetQuery = &quot;&quot;&quot;
                INSERT INTO ${targetTable}
                (${ targetFields.collect { it.name }.join(', ') })
                VALUES
                (${ targetFields.collect { '?' }.join(', ') })
            &quot;&quot;&quot; as String

            Sql.withInstance(
                targetDbUrl,
                targetDbUser,
                targetDbPassword,
            ) { def targetDb -&gt;
                if (createTable) {
                    println 'Creating table...'
                    targetDb.execute &quot;&quot;&quot;
                        CREATE TABLE ${targetTable}
                        (${ targetFields.collect { it.name + ' ' + it.type }.join(', ') })
                    &quot;&quot;&quot; as String
                    println 'Table created'
                } else if (truncateTable){
                    println 'Truncating table...'
                    targetDb.execute &quot;&quot;&quot;
                        TRUNCATE TABLE ${targetTable}
                    &quot;&quot;&quot; as String
                    println 'Table truncated'
                }
                def counter = 0
                targetDb.withBatch(batchSize, targetQuery) { ps -&gt;
                    sourceDb.eachRow(sourceQuery) { row -&gt;
                        println &quot;${++counter}. Adding row ${row}&quot;
                        ps.addBatch(toBatchParams(targetFields, row))
                    }
                }
                println &quot;${counter} rows added to ${targetTable}&quot;
            }
        }
    }
}

def toBatchParams(def targetFields, def row) {
<span class="nc" id="L97">    targetFields.collect {</span>
        row[it.name]
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>